<!DOCTYPE html>

<html>

<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}
#group{
  position: absolute;
  top: 20px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}
#KeyboardPress{
  position: absolute;
  top: 30px;
  width: 100%;
  padding:10px;
  text-align: left;
  color: #ffff00
}
body {
  overflow:;
}

</style>
</head>

<body>
<div id="info">HW4 </div>
<div id="group">
Group steer: No Method</div>
<div id="KeyboardPress">
KeyBoardPress 1 is Cohesion<br>
KeyBoardPress 2 is Separation<br>
KeyBoardPress 3 is Alignment<br>
KeyBoardPress 0 is No Method
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script>
var camera, scene, renderer, controls;
var puck;
var agent;
var angle = 0;
var targetCatch = false;
var targetOmega = 0.3;
var raycaster;
var mouse = new THREE.Vector2();
var pickables = [];
var objects=[];
var keyboard = new KeyboardState();

var obCen = new THREE.Vector3(50,0,30);
var obCen1 = new THREE.Vector3(-50,0,30);
var obCen2 = new THREE.Vector3(0,0,-50);

var obRad = 30;
var obRad2 = 25;
var mass = 1;
var clock = new THREE.Clock();
var steertype = 0;
var target = new THREE.Vector3();

var Agent = function(mesh, initPos) {
  this.pos = new THREE.Vector3();
  if (initPos) this.pos.copy(initPos);

  this.vel = new THREE.Vector3();
  this.force = new THREE.Vector3();
  this.target = new THREE.Vector3();
  this.angle = 0
  this.mesh = mesh;
  this.maxSpeed = 60;
  this.maxForce = 60;

  this.setTarget = function(target) {
    this.target.copy(target);
  }

  this.update = function(dt) {
    // compute force
    this.force = this.target.clone().sub(this.pos).setLength(this.maxSpeed).sub(this.vel);
    
    // collision avoidance
    // (for each obstacle)
    var tmp = obCen.clone().sub(this.pos);
    var tmpProj = tmp.clone().projectOnVector(this.vel);
    
    //console.log (tmp.dot(this.vel));
    
    if (tmp.dot(this.vel) > 0) {
     if (tmpProj.clone().sub(tmp).length() < obRad + 3) {
       
       if (tmpProj.length() < 5*this.vel.length()) {
         console.log ('block & close');
       this.force.add (tmpProj.clone().sub(tmp).multiplyScalar(2));     
        }
      }
    }  
    
    var tmp1 = obCen1.clone().sub(this.pos);
    var tmpProj1 = tmp1.clone().projectOnVector(this.vel);
    
    //console.log (tmp.dot(this.vel));
    
    if (tmp1.dot(this.vel) > 0) {
     if (tmpProj1.clone().sub(tmp1).length() < obRad + 3) {
       
       if (tmpProj1.length() < 5*this.vel.length()) {
         console.log ('block & close');
       this.force.add (tmpProj1.clone().sub(tmp1).multiplyScalar(2));     
        }
      }
    }  
    
    var tmp2 = obCen2.clone().sub(this.pos);
    var tmpProj2 = tmp2.clone().projectOnVector(this.vel);
    
    //console.log (tmp.dot(this.vel));
    
    
    if (tmp2.dot(this.vel) > 0) {
     if (tmpProj2.clone().sub(tmp2).length() < obRad2 + 3) {
       
       if (tmpProj2.length() < 5*this.vel.length()) {
         console.log ('block & close');
       this.force.add (tmpProj2.clone().sub(tmp2).multiplyScalar(2));     
        }
      }
    }  
    
  //Cohesion,Separation,Alignment
  //https://gamedevelopment.tutsplus.com/tutorials/3-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444
 	if(steertype ==1){
    var countFish =0;
    var fishPosition = new THREE.Vector3(0,0,0);
    for(var i=0;i<6;i++){
      if(objects[i].pos.distanceTo(this.pos)<35){
        if(objects[i]!=this){
          fishPosition.add(objects[i].pos.clone());
          countFish++;
        }
      }
    }
    if(countFish>1){
      fishPosition.divideScalar(countFish);
      fishPos = this.pos.clone().sub(fishPosition);//.multiplyScalar(15);
      this.vel.add(fishPos.normalize());
    }
  }
  else if(steertype ==2){
    var countFish =0;
    var fishVel = new THREE.Vector3(0,0,0);
    for(var i=0;i<6;i++){
      if(objects[i].pos.distanceTo(this.pos)<20){
        if(objects[i]!=this){
          fishVel.add(objects[i].pos.clone().sub(this.pos));
          countFish++;
        }
      }
    }
    if(countFish>1){
      fishVel.x*=-1.5;
      fishVel.z*=-1.5;
      this.vel.add(fishVel);
    }
  }  
  else if(steertype==3){
    var countFish =0;
    var fishVel = new THREE.Vector3(0,0,0);
    for(var i=0;i<6;i++){
      if(objects[i].pos.distanceTo(this.pos)<20){
        if(objects[i]!=this){
          fishVel.add(objects[i].vel.clone());
          countFish++;
        }
      }
    }
    if(countFish>1){
      fishVel.divideScalar(countFish);
      this.vel.add(fishVel.normalize());
    }
  }

		// force clamping
    if (this.force.length() > this.maxForce)
      this.force.setLength(this.maxForce);
    this.vel.add(this.force.clone().multiplyScalar(dt));

    // velocity clamping
    if (this.vel.length() > this.maxSpeed)
      this.vel.setLength(this.maxSpeed);
    this.pos.add(this.vel.clone().multiplyScalar(dt));

    if (this.vel.length() > 0.001) {
      this.angle = Math.atan2(-this.vel.z, this.vel.x);
    }
    this.mesh.position.copy(this.pos);
    this.mesh.rotation.y = this.angle;

    // catch handling
    if (this.pos.distanceTo(this.target) < 2) {
      this.vel.set(0, 0, 0);
      angle = Math.random() * Math.PI * 2;
  }

  }
}

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set (0,100,200);
  scene.add(camera);

  var gridXZ = new THREE.GridHelper(100, 10);
  gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
  scene.add(gridXZ);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  document.body.appendChild(renderer.domElement);

  //////////////////////
 var ob = new THREE.Mesh (new THREE.CylinderGeometry(obRad, obRad, 7, 60));
  ob.position.set(50,3.5,30);
 scene.add (ob);
  
  var ob1 = new THREE.Mesh (new THREE.CylinderGeometry(obRad, obRad, 7, 60));
  ob1.position.set(-50,3.5,30);
 scene.add (ob1);
   
  var ob2 = new THREE.Mesh (new THREE.CylinderGeometry(obRad2, obRad2, 7, 60));
  ob2.position.set(0,3.5,-50);
 scene.add (ob2);

  var geometry = new THREE.BoxGeometry(15, 2, 5);
  var material = new THREE.MeshNormalMaterial();
  var box = new THREE.Mesh(geometry, material);
  
  for(var i =0;i<6;i++){
    tmp= new Agent(box.clone(),new THREE.Vector3(Math.floor((Math.random() * 300) + 1)-100,0,Math.floor((Math.random() * 300) + 1)-150));
    
    
    objects.push(tmp);
    scene.add(objects[i].mesh);
  }
  
  
  plane = new THREE.Mesh (new THREE.PlaneGeometry(200,200), new THREE.MeshBasicMaterial({visible:false}));
  scene.add (plane);
  plane.rotation.x = -Math.PI/2;
 pickables = [plane];
  
  puck = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 2, 20), new THREE.MeshNormalMaterial());
  scene.add(puck);
  
  raycaster = new THREE.Raycaster();
  document.addEventListener('mousedown', onDocumentMouseDown, false);
 target.set (puck.position.x,puck.position.y,puck.position.z);
}

function onDocumentMouseDown(event) {

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 console.log(mouse.x,mouse.y);
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
     puck.position.copy (intersects[0].point);
  }
}

function animate() {
 keyboard.update();
  var dt = clock.getDelta();
  if(keyboard.down ('1')){
    steertype=1;
    document.getElementById('group').innerHTML = "Group steer: Cohesion"
  }
  if(keyboard.down ('2')){
    steertype=2;
    document.getElementById('group').innerHTML = "Group steer: Separation"
  }
  if(keyboard.down ('3')){
    steertype=3;
    document.getElementById('group').innerHTML = "Group steer: Alignment "
  }
  if(keyboard.down ('0')){
    steertype=0;
    document.getElementById('group').innerHTML = "Group steer: No Method"
  }
    
  for(var i=0;i<6;i++)
     objects[i].update(dt);// delta-time

    angle += targetOmega * dt;

    target.set (puck.position.x,puck.position.y,puck.position.z);

   for(var i=0;i<6;i++)
     objects[i].setTarget(target);
  
  	controls.update();
    requestAnimationFrame(animate);
    render();
}

function render() {
  renderer.render(scene, camera);
}
window.focus();
</script>
</body>
</html>