<!DOCTYPE html>

<html>

<head>
<style>
	#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}


</style>
</head>

<body> 
	<div id="info">hw5 helper</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r78/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">


</script>

<script>
var camera, scene, renderer, controls;
var vehicle;

var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var pickables = [];

var pos, vel, force;
var angle = 0;
var uvOffsetArray = [];
var baseS = 0,
  baseT = 0;
var counter = 0;
var sprite;
var mass = 1;
var clock = new THREE.Clock();

var obCen = new THREE.Vector3(0,100,0);
var obCen1 = new THREE.Vector3(150,50,0);
var obCen2 = new THREE.Vector3(-150,50,0);
var obRad = 80;
var obRad2 = 40;
var obRad3 = 40;
var target = new THREE.Vector3();
var maxSpeed = 60;
var maxForce = 20;

init();
animate();

function setUpOffsetArray() {
  var rowCount = 4; // 4x8 sprites
  var colCount = 8;
  for (var i = 0; i < rowCount; i++) {
    var row = [];
    for (var j = 0; j < colCount; j++)
      row.push(new THREE.Vector2(j * 0.125, - 0.25 * i));
    uvOffsetArray.push(row);
  }
}

function buildSprite(texMat) {
  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-15, -15, 0),
    new THREE.Vector3(15, -15, 0),
    new THREE.Vector3(15, 15, 0),
    new THREE.Vector3(-15, 15, 0)
  );

  var face;
  face = new THREE.Face3(0, 1, 2);
  geometry.faces.push(face);
  face = new THREE.Face3(0, 2, 3);
  geometry.faces.push(face);

	// upper left corner
	var uv0 = new THREE.Vector2(0.0,0.75);
	var uv1 = new THREE.Vector2(0.125,0.75);
	var uv2 = new THREE.Vector2(0.125,1.0);
	var uv3 = new THREE.Vector2(0.0,1.0);
  
  geometry.faceVertexUvs[0].push([uv0, uv1, uv2]);
  geometry.faceVertexUvs[0].push([uv0, uv2, uv3]);

  geometry.computeBoundingSphere();
  geometry.computeFaceNormals();
  geometry.computeVertexNormals();

  sprite = new THREE.Mesh(geometry, texMat);
  scene.add(sprite);
	sprite.visible=false;
}

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.y = 200;
  camera.position.z = 400;
  scene.add(camera);
  /*
    // add my cylinder
    var geometry = new THREE.BoxGeometry(15, 2, 5);
    var material = new THREE.MeshNormalMaterial();
    vehicle = new THREE.Mesh(geometry, material);
    scene.add(vehicle);
  */
  setUpOffsetArray();

  // instantiate a loader
  var loader = new THREE.TextureLoader();

  // load a resource
  loader.load(
    // resource URL
    'https://i.imgur.com/6ePTx6p.png',

    // Function when resource is loaded
    function(texture) {
      // Plane with default texture coordinates [0,1]x[0,1]
      var texMat = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true, // cutout texture: set transparent: true
        side: THREE.DoubleSide
      });
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      buildSprite(texMat);
    },
    // Function called when download progresses
    function(xhr) {
      console.log((xhr.loaded / xhr.total * 100) + '% loaded');
    },
    // Function called when download errors
    function(xhr) {
      console.log('An error happened');
    }
  );

  
  var gridXZ = new THREE.GridHelper(200, 40, 'red', 'white');
  scene.add(gridXZ);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  //////////////////////
  
  var ob = new THREE.Mesh (new THREE.SphereGeometry (obRad,20,20),
  new THREE.MeshNormalMaterial({wireframe:true}));
  ob.position.set(0,90,0);
  scene.add (ob);
  
  var ob1 = new THREE.Mesh (new THREE.SphereGeometry (obRad2,20,20),
  new THREE.MeshNormalMaterial({wireframe:true}));
  ob1.position.set(150,50,0);
  scene.add (ob1);
  
  var ob2 = new THREE.Mesh (new THREE.SphereGeometry (obRad3,20,20),
  new THREE.MeshNormalMaterial({wireframe:true}));
  ob2.position.set(-150,50,0);
  scene.add (ob2);
  
 	pos = new THREE.Vector3();
	vel = new THREE.Vector3(120,0,0);
	force = new THREE.Vector3();

	missile = new THREE.Object3D();
  normalMat = new THREE.MeshNormalMaterial();
	tip = new THREE.Mesh (new THREE.CylinderGeometry (0,5,10,20), normalMat);
  body = new THREE.Mesh (new THREE.CylinderGeometry (5,5,20,20), normalMat);
 	body.add (tip);
  tip.position.y = 10/2 + 20/2;
  body.position.y = 20/2;
 
 	missile.add (body);
  missile.rotation.z = -Math.PI/2;
  vehicle = new THREE.Object3D();
  vehicle.add (missile);

  scene.add(vehicle);
  
  vehicle.rotation.y = 0;//-Math.PI/4;
  vehicle.rotation.z = Math.PI/6;
  vehicle.position.set (-280,0,-280);
  
  pos.copy (vehicle.position);
  vel.applyEuler (vehicle.rotation);

  document.body.appendChild(renderer.domElement);

  plane = new THREE.Mesh(new THREE.PlaneGeometry(400, 400, 10, 10), new THREE.MeshBasicMaterial({
    side: THREE.DoubleSide,
    color: 0xff0000
  }));
  scene.add(plane);
  plane.position.x = 0;
  plane.rotation.x = -Math.PI / 2;

  var plane2 = plane.clone();
  //scene.add(plane2);
  plane2.position.x = 150;
  plane2.position.y = 100;
  //plane.rotation.x = -Math.PI / 2;
  pickables = [plane];

  puck = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 20), new THREE.MeshNormalMaterial());
  scene.add(puck);
  
  

    
  
  document.addEventListener('mousedown', onDocumentMouseDown, false);
}


function computeForce() {
  force = target.clone().sub(pos).setLength(maxSpeed).sub(vel);

  // collision avoidance
  // (for each obstacle)
  var tmp = obCen.clone().sub(pos);
  var tmp2 = obCen1.clone().sub(pos);
  var tmp3 = obCen2.clone().sub(pos);
  var tmpProj = tmp.clone().projectOnVector(vel);
	var tmpProj2 = tmp2.clone().projectOnVector(vel);
  var tmpProj3 = tmp3.clone().projectOnVector(vel);
  if (tmp.dot(vel) > 0) {
    if (tmpProj.clone().sub(tmp).length() < obRad + 2) {

      if (tmpProj.length() < 5 * vel.length()) {
        console.log('block & close');
        force.add(tmpProj.clone().sub(tmp).multiplyScalar(2));
      }
    }
  }
  if (tmp2.dot(vel) > 0) {
    if (tmpProj2.clone().sub(tmp2).length() < obRad2 + 3) {

      if (tmpProj2.length() < 5 * vel.length()) {
        console.log('block & close');
        force.add(tmpProj2.clone().sub(tmp2).multiplyScalar(2));
      }
    }
  }
  if (tmp3.dot(vel) > 0) {
    if (tmpProj3.clone().sub(tmp3).length() < obRad3 + 3) {

      if (tmpProj3.length() < 5 * vel.length()) {
        console.log('block & close');
        force.add(tmpProj3.clone().sub(tmp3).multiplyScalar(2));
      }
    }
  }

}

function vectorClamp(v, vMax) {
  if (v.length() > vMax)
    v.setLength(vMax);
}


function onDocumentMouseDown(event) {
  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
  	
    puck.position.copy(intersects[0].point);
    target.copy(puck.position);
  }

}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function spriteAnimate() {
  console.log (uvOffsetArray[baseS][baseT]);
  
	sprite.material.map.offset.copy (uvOffsetArray[baseS][baseT]);  
  baseT = (baseT + 1) % 8;
  if (baseT === 0) {
    baseS = (baseS + 1) % 4;
  }
}

function animate() {
	
  computeForce();
  var dt = clock.getDelta(); // delta-time

  vectorClamp(force, maxForce);
  vel.add(force.clone().multiplyScalar(dt / mass));
  vectorClamp(vel, maxSpeed);
  pos.add(vel.clone().multiplyScalar(dt));

  if (vel.length() > 0.001) {
    angle = Math.atan2(-vel.z, vel.x);
  }
  //controls.update();
	
  
  
	if(pos.clone().sub(puck.position).length()<10){
   		puck.visible=false;
      vehicle.visible=false;
   		sprite.position.copy(puck.position);
      sprite.visible=true;
  }
  
  counter++;
 			if (counter % 14 === 0)
      	spriteAnimate();
	//sprite.visible=false;
	if(counter>800)
  	sprite.visible=false;
  // set orientation
  var localX = vel.clone().normalize();
  var localY = new THREE.Vector3(0, 1, 0);
  var tmp = localY.clone().projectOnVector(localX);
  localY.sub(tmp).normalize();
  var localZ = new THREE.Vector3();
  localZ.crossVectors(localX, localY);

  vehicle.matrix.makeBasis(localX, localY, localZ);
  vehicle.matrix.setPosition(pos);
  vehicle.matrixAutoUpdate = false;
	

  requestAnimationFrame(animate);
  render();
}

function render() {
  renderer.render(scene, camera);
}


</script>
</body>

</html>
